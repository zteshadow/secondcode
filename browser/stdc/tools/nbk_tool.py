# -*- coding: utf-8 -*-

import os
import string

def gen_tag():

    os.chdir('c:/nbk/stdc/dom')

    T1 = '/* This file is automatically generated from xml_tags.in */\n\n'
    T11 ='''#ifndef __XML_TAGS_H__
#define __XML_TAGS_H__

#ifdef __cplusplus
extern "C" {
#endif

extern const char* XmlTagNames[];

enum TAGS {
'''
    T13 = '''};

#ifdef __cplusplus
}
#endif

#endif
'''
    T14 = '\tTAGID_%s = %d,\n'

    T15 = '''#include "xml_tags.h"

const char* XmlTagNames[] = {
    0,
'''
    T16 = '};\n'
    T17 = '\t\"%s\",\n'
    T18 = '\t\"text\"\n'

    # 生成h
    
    f = open('xml_tags.in', 'r')
    lines = f.readlines()
    f.close()

    f = open('xml_tags.h', 'w')
    f.write(T1);
    f.write(T11);

    n = 1
    for l in lines:
        l = string.strip(l)
        if len(l) == 0:
            continue
        
        s = T14 % (string.upper(l), n)
        f.write(s)
        n += 1

    s = T14 % ('TEXT', n)
    f.write(s)
    s = T14 % ('LASTTAG', n)
    f.write(s)
    s = '\tTAGID_CLOSETAG = 32000\n'
    f.write(s)
    
    f.write(T13);
    f.close()

    # 生成c

    f = open('xml_tags.c', 'w')
    f.write(T1);
    f.write(T15);

    for l in lines:
        l = string.strip(l)
        if len(l) == 0:
            continue
        
        s = T17 % l
        f.write(s)

    f.write(T18)
    f.write(T16)
    f.close()
    

def gen_att():

    os.chdir('c:/nbk/stdc/dom')

    T1 = '/* This file is automatically generated from xml_atts.in */\n\n'
    T11 ='''#ifndef __XML_ATTS_H__
#define __XML_ATTS_H__

#ifdef __cplusplus
extern "C" {
#endif

extern const char* XmlAttNames[];

enum ATTS {
'''
    T13 = '''};

#ifdef __cplusplus
}
#endif

#endif
'''
    T14 = '\tATTID_%s = %d,\n'

    T15 = '''#include "xml_atts.h"

const char* XmlAttNames[] = {
    0,
'''
    T16 = '};\n'
    T17 = '\t"%s",\n'
    T18 = '\t"z"\n'

    # 生成h
    
    f = open('xml_atts.in', 'r')
    lines = f.readlines()
    f.close()

    f = open('xml_atts.h', 'w')
    f.write(T1);
    f.write(T11);

    n = 1
    for l in lines:
        l = string.strip(l)
        if len(l) == 0:
            continue

        l = string.replace(l, '-', '_')
        s = T14 % (string.upper(l), n)
        f.write(s)
        n += 1

    s = '\tATTID_Z = %d,\n' % n
    f.write(s)
    s = '\tATTID_LASTATT = %d\n' % n
    f.write(s)
    
    f.write(T13);
    f.close()

    # 生成c

    f = open('xml_atts.c', 'w')
    f.write(T1);
    f.write(T15);

    for l in lines:
        l = string.strip(l)
        if len(l) == 0:
            continue
        
        s = T17 % l
        f.write(s)

    f.write(T18)
    f.write(T16)
    f.close()


def gen_color():

    os.chdir('c:/nbk/stdc/css')

    T1 = '/* This file is automatically generated from color.in */\n\n'
    T2 = '''#ifndef __COLOR_H__
#define __COLOR_H__

#include "../inc/nbk_gdi.h"

#ifdef __cplusplus
extern "C" {
#endif
    
'''
    T3 = '''
#ifdef __cplusplus
}
#endif

#endif
'''
    T4 = 'extern const NColor color%s;\n'
    T5 = 'const NColor color%s = {%s, %s, %s, %s};\n'
    T6 = '#include "color.h"\n\n'

    T10 = 'extern const char* colorNames[];\n\n'
    T11A = 'enum COLORS {\n'
    T11B = '};\n'
    T12 = '\tCC_%s = %d,\n'
    
    T13A = 'const char* colorNames[] = {\n\t0,\n'
    T13B = '};\n'
    T14 = '\t"%s"'
    
    T20 = 'extern const NColor colorValues[];\n\n'
    T21A = 'const NColor colorValues[] = {\n\t{0, 0, 0, 0},\n'
    T21B = '};\n'
    T22 = '\t{%s, %s, %s, %s}'

    f = open('color.in', 'r')
    lines = f.readlines()
    f.close()

    # 生成头文件
    f = open('color.h', 'w')
    f.write(T1)
    f.write(T2)

    # 生成color常量
    for l in lines:
        l = string.strip(l)
        if len(l) == 0:
            continue

        m = string.split(l, ',')
        s = T4 % (m[0])
        f.write(s)

    f.write('\n')
    n = 1

    f.write(T10);
    f.write(T20);
    
    # 生成color id
    f.write(T11A);
    for l in lines:
        l = string.strip(l)
        if len(l) == 0:
            continue

        m = string.split(l, ',')
        s = T12 % (string.upper(m[0]), n)
        f.write(s)
        n += 1

    s = '\tCC_LASTCOLOR = %d\n' % (n-1)
    f.write(s)
    f.write(T11B)

    f.write(T3)
    f.close()

    # 生成源文件
    f = open('color.c', 'w')
    f.write(T1)
    f.write(T6)

    # 生成color常量值
    for l in lines:
        l = string.strip(l)
        if len(l) == 0:
            continue

        m = string.split(l, ',')
        s = T5 % (m[0], m[1], m[2], m[3], m[4])
        f.write(s)

    # 生成color名表
    f.write('\n')
    f.write(T13A)
    n = 1
    for l in lines:
        l = string.strip(l)
        if len(l) == 0:
            continue

        if n > 1:
            f.write(',\n')

        m = string.split(l, ',')
        s = T14 % (string.lower(m[0]))
        f.write(s)
        n += 1
        
    f.write('\n')
    f.write(T13B)

    # 生成color值表
    f.write('\n')
    f.write(T21A)
    n = 1
    for l in lines:
        l = string.strip(l)
        if len(l) == 0:
            continue

        if n > 1:
            f.write(',\n')

        m = string.split(l, ',')
        s = T22 % (m[1], m[2], m[3], m[4])
        f.write(s)
        n += 1

    f.write('\n')
    f.write(T21B);

    f.close()
        

def gen_prop():
    
    os.chdir('c:/nbk/stdc/css')

    T1 = '/* This file is automatically generated from css_prop.in */\n\n'
    T2 = '''#ifndef __CSS_PROP_H__
#define __CSS_PROP_H__

#ifdef __cplusplus
extern "C" {
#endif
    
'''
    T3 = '''
#ifdef __cplusplus
}
#endif

#endif
'''
    T4 = 'extern const char* cssPropNames[];\n\n'
    T5 = 'enum NCSSPROP {\n'
    T6 = '\tCSSID_%s = %d'
    T7 = '\n};\n'
    T8 = '\tCSSID_LAST = %d'

    T10 = '#include "css_prop.h"\n\n'
    T11 = 'const char* cssPropNames[] = {\n'
    T12 = '\t"%s"'
    T13 = '\n};\n'

    # 生成 .h
    
    f = open('css_prop.in', 'r')
    lines = f.readlines()
    f.close()

    f = open('css_prop.h', 'w')
    f.write(T1)
    f.write(T2)
    f.write(T4)
    f.write(T5)

    n = 1
    for l in lines:
        l = string.strip(l)
        if len(l) == 0:
            continue

        l = string.upper(l)
        l = string.replace(l, '-', '_')
        l = T6 % (l, n)
        if n > 1:
            f.write(',\n')
        f.write(l)
        n += 1

    f.write(',\n')
    n -= 1
    f.write(T8 % n)
    f.write(T7)
    f.write(T3)
    f.close()
    
    # 生成 .c

    f = open('css_prop.c', 'w')
    f.write(T1)
    f.write(T10)
    f.write(T11)

    n = 0
    max_len = 0
    for l in lines:
        l = string.strip(l)
        if len(l) == 0:
            continue

        max_len = max(max_len, len(l))
        if n == 0:
            f.write('\t0')
        n += 1
        l = T12 % l
        f.write(',\n')
        f.write(l)

    f.write(T13)
    f.close()
    print 'Total: %d Max-Length: %d' % (n, max_len)
    

def gen_value():
    
    os.chdir('c:/nbk/stdc/css')

    T1 = '/* This file is automatically generated from css_value.in */\n\n'
    T2 = '''#ifndef __CSS_VALUE_H__
#define __CSS_VALUE_H__

#ifdef __cplusplus
extern "C" {
#endif
    
'''
    T3 = '''
#ifdef __cplusplus
}
#endif

#endif
'''
    T4 = 'extern const char* cssValueNames[];\n\n'
    T5 = 'enum NCSSVALUE {\n'
    T6 = '\tCSSVAL_%s = %d'
    T7 = '\n};\n'
    T8 = '\tCSSVAL_LAST = %d'

    T10 = '#include "css_value.h"\n\n'
    T11 = 'const char* cssValueNames[] = {\n'
    T12 = '\t"%s"'
    T13 = '\n};\n'

    # 生成 .h
    
    f = open('css_value.in', 'r')
    lines = f.readlines()
    f.close()

    h = T1
    h += T2
    h += T4
    h += T5

    n = 1
    for l in lines:
        l = string.strip(l)
        if len(l) == 0:
            continue

        l = string.upper(l)
        l = string.replace(l, '-', '_')
        l = T6 % (l, n)
        if n > 1:
            h += ',\n'
        h += l
        n += 1

    h += ',\n'
    n -= 1
    h += T8 % n
    h += T7
    h += T3
    
    # 生成 .c

    c = T1
    c += T10
    c += T11

    n = 0
    max_len = 0
    for l in lines:
        l = string.strip(l)
        if len(l) == 0:
            continue

        max_len = max(max_len, len(l))
        if n == 0:
            c += '\t0'
        n += 1
        l = T12 % l
        c += ',\n'
        c += l

    c += T13

    f = open('css_value.h', 'w')
    f.write(h)
    f.close()

    f = open('css_value.c', 'w')
    f.write(c)
    f.close()
    
##    print h
##    print '==========================================='
##    print c
    
    print 'Total: %d Max-Length: %d' % (n, max_len)


def gen_ref():
    
    os.chdir('c:/nbk/stdc/dom')

    T1 = '/* This file is automatically generated from char_ref.in */\n\n'
    T2 = '''#ifndef __CHAR_REF_H__
#define __CHAR_REF_H__

#ifdef __cplusplus
extern "C" {
#endif
    
'''
    T3 = '''
#ifdef __cplusplus
}
#endif

#endif
'''
    T4 = 'extern const char* charrefTable[];\n'
    T5 = 'extern const char* entityTable[];\n'
    T6 = '#define CHARREF_TOTAL\t%d\n\n'

    T8 = '#include "char_ref.h"\n\n'

    T10 = 'const char* charrefTable[] = {\n'    
    T11 = 'const char* entityTable[] = {\n'
    T12 = '\n};\n'
    
    T15 = '\t"%s"'

    f = open('char_ref.in', 'r')
    lines = f.readlines()
    f.close()

    a1 = T10
    a1 += '\t0'
    a2 = T11
    a2 += '\t0'
    
    n = 1
    for l in lines:
        l = l[:-1]
        m = string.split(l, ',')
        a1 += ',\n'
        a1 += T15 % m[0]
        a2 += ',\n'
        a2 += T15 % m[1]
        n += 1

    a1 += T12
    a2 += T12

    h = T1
    h += T2
    h += T6 % (n - 1)
    h += T4
    h += T5
    h += T3

    c = T1
    c += T8
    c += a1
    c += '\n'
    c += a2

    f = open('char_ref.h', 'w')
    f.write(h)
    f.close()

    f = open('char_ref.c', 'w')
    f.write(c)
    f.close()

##    print h
##    print '==========================================='
##    print c
    



def gen_enum(inFile, idPre, lst=[]):
    if len(lst):
        lines = lst
    else:
        f = open(inFile, 'r')
        lines = f.readlines()
        f.close()

    enum = ''
    max_length = 0
    i = 1
    for l in lines:
        l = string.strip(l)
        if  len(l) == 0:
            continue

        max_length = max(max_length, len(l))
        l = string.upper(l)
        l = string.replace(l, '-', '_')
        if i > 1:
            enum += ',\n'
        s = '\t%s%s = %d' % (idPre, l, i)
        i += 1

        enum += s

    return (enum, i, max_length)
    
def gen_string(lines, reserved = True, numPreRow=9):

    num = numPreRow
    
    str = ''
    if reserved:
        i = 1
    else:
        i = 0
    j = 0
    for l in lines:
        if l[-1] == '\n':
            l = l[:-1]
        if len(l) == 0:
            continue

        if j == 0:
            str += '\t\t"'

        if i > 0:
            str += ','
        str += l
        
        if j == num:
            str += '" \\\n'

        i += 1
        if j == num:
            j = 0
        else:
            j += 1

    if j > 0 and j <= num:
        str += '" \\\n'

    return str
    
    
s_comment = '/* this file is generated automatically */\n'
s_cpp_begin = '\n#ifdef __cplusplus\nextern "C" {\n#endif\n\n'
s_cpp_end = '\n#ifdef __cplusplus\n}\n#endif\n\n'

# 生成标记

def create_tags():
    os.chdir('c:/nbk/stdc/dom')

    # 生成头文件
    doth = s_comment
    doth += '''
#ifndef __XML_TAGS_H__
#define __XML_TAGS_H__
'''
    doth += s_cpp_begin

    doth += 'enum TAGS {\n'
    ret = gen_enum('xml_tags.in', 'TAGID_')
    doth += ret[0]
    doth += ',\n'
    doth += '\tTAGID_TEXT = %d,\n' % ret[1]
    doth += '\tTAGID_LASTTAG = %d,\n' % ret[1]
    doth += '\tTAGID_CLOSETAG = 32000\n'
    doth += '};\n'

    doth += '\n#define MAX_TAG_LEN\t%d\n' % ret[2]

    doth += '''
void xml_initTags(void);
void xml_delTags(void);
const char** xml_getTagNames(void);
'''

    doth += s_cpp_end
    doth += '#endif\n'

    f = open('xml_tags.h', 'w')
    f.write(doth)
    f.close()

    print 'tag total: %d\t max length %d' % (ret[1], ret[2])

    # 生成源文件
    dotc = s_comment

    dotc += '''
#include "../inc/config.h"
#include "../tools/strList.h"
#include "xml_tags.h"

static NStrList* l_xmlTagNames = N_NULL;

void xml_initTags(void)
{
    const char* tags = \\
'''

    f = open('xml_tags.in', 'r')
    lines = f.readlines()
    f.close()
    dotc += gen_string(lines)
    dotc += '\t\t",text";\n'
    
    dotc += '''
    l_xmlTagNames = strList_create(tags);
}

void xml_delTags(void)
{
    strList_delete(&l_xmlTagNames);
}

const char** xml_getTagNames(void)
{
    return (const char**)l_xmlTagNames->lst;
}
'''

    f = open('xml_tags.c', 'w')
    f.write(dotc)
    f.close()
    

# 生成属性

def create_atts():
    os.chdir('c:/nbk/stdc/dom')

    # 生成头文件
    doth = s_comment
    doth += '''
#ifndef __XML_ATTS_H__
#define __XML_ATTS_H__
'''
    doth += s_cpp_begin

    doth += 'enum ATTS {\n'
    ret = gen_enum('xml_atts.in', 'ATTID_')
    doth += ret[0]
    doth += ',\n'
    doth += '\tATTID_LASTATT = %d\n' % (ret[1] - 1)
    doth += '};\n'

    doth += '''
void xml_initAtts(void);
void xml_delAtts(void);
const char** xml_getAttNames(void);
'''

    doth += s_cpp_end
    doth += '#endif\n'

    f = open('xml_atts.h', 'w')
    f.write(doth)
    f.close()

    # 生成源文件
    dotc = s_comment

    dotc += '''
#include "../inc/config.h"
#include "../tools/strList.h"
#include "xml_atts.h"

static NStrList* l_xmlAttNames = N_NULL;

void xml_initAtts(void)
{
    const char* atts = \\
'''

    f = open('xml_atts.in', 'r')
    lines = f.readlines()
    f.close()
    dotc += gen_string(lines)
    dotc += '\t\t;\n'
    
    dotc += '''
    l_xmlAttNames = strList_create(atts);
}

void xml_delAtts(void)
{
    strList_delete(&l_xmlAttNames);
}

const char** xml_getAttNames(void)
{
    return (const char**)l_xmlAttNames->lst;
}
'''
    
    f = open('xml_atts.c', 'w')
    f.write(dotc)
    f.close()


# 生成字符引用

def create_refs():
    os.chdir('c:/nbk/stdc/dom')

    f = open('char_ref.in', 'r')
    lines = f.readlines()
    f.close()

    ref = []
    char = []
    for l in lines:
        l = l[:-1]
        if len(l) == 0:
            continue
        m = string.split(l, ',')
        ref.append(m[0])
        char.append(m[1])

    # 生成头文件
    doth = s_comment
    doth += '''
#ifndef __CHAR_REF_H__
#define __CHAR_REF_H__
'''
    doth += s_cpp_begin
    doth += '#define CHARREF_TOTAL\t%d\n' % len(ref)
    doth += '''
void xml_initEntityTable(void);
void xml_delEntityTable(void);
const char** xml_getCharrefNames(void);
const char** xml_getEntityNames(void);
'''
    doth += s_cpp_end
    doth += '#endif\n'

    f = open('char_ref.h', 'w')
    f.write(doth)
    f.close()

    # 生成源文件
    dotc = s_comment
    dotc += '''
#include "../inc/config.h"
#include "../tools/strList.h"
#include "char_ref.h"

static NStrList* l_charref = N_NULL;
static NStrList* l_entity = N_NULL;

void xml_initEntityTable(void)
{
    const char* refs = \\
'''
    dotc += gen_string(ref)
    dotc += '''     ;
    const char* ents = \\
'''
    dotc += gen_string(char)
    dotc += '''     ;
        
    l_charref = strList_create(refs);
    l_entity = strList_create(ents);
}

void xml_delEntityTable(void)
{
    strList_delete(&l_charref);
    strList_delete(&l_entity);
}

const char** xml_getCharrefNames(void)
{
    return (const char**)l_charref->lst;
}

const char** xml_getEntityNames(void)
{
    return (const char**)l_entity->lst;
}
'''
    f = open('char_ref.c', 'w')
    f.write(dotc)
    f.close()
    

# 生成样式属性

def create_prop():
    os.chdir('c:/nbk/stdc/css')

    # 生成头文件
    doth = s_comment
    doth += '''
#ifndef __CSS_PROP_H__
#define __CSS_PROP_H__
'''
    doth += s_cpp_begin

    doth += 'enum NCSSPROP {\n'
    ret = gen_enum('css_prop.in', 'CSSID_')
    doth += ret[0]
    doth += ',\n'
    doth += '\tCSSID_LAST = %d\n' % (ret[1] - 1)
    doth += '};\n'

    doth += '\n#define MAX_CSS_PROP_LEN\t%d\n' % ret[2]
    
    doth += '''
void css_initProp(void);
void css_delProp(void);
const char** css_getPropNames(void);
'''
    doth += s_cpp_end
    doth += '#endif\n'

    f = open('css_prop.h', 'w')
    f.write(doth)
    f.close()
    
    print 'property total %d\t max length %d' % (ret[1], ret[2])
    
    # 生成源文件
    dotc = s_comment
    dotc += '''
#include "../inc/config.h"
#include "../tools/strList.h"
#include "css_prop.h"

static NStrList* l_cssPropNames = N_NULL;

void css_initProp(void)
{
    const char* props = \\
'''

    f = open('css_prop.in','r')
    lines = f.readlines()
    f.close()

    dotc += gen_string(lines, True, 4)
    dotc += '\t\t;\n'
    dotc += '''
    l_cssPropNames = strList_create(props);
}

void css_delProp(void)
{
    strList_delete(&l_cssPropNames);
}

const char** css_getPropNames(void)
{
    return (const char**)l_cssPropNames->lst;
}
'''

    f = open('css_prop.c', 'w')
    f.write(dotc)
    f.close()
    

# 生成样式值

def create_vals():
    os.chdir('c:/nbk/stdc/css')

    # 生成头文件
    doth = s_comment
    doth += '''
#ifndef __CSS_VALUE_H__
#define __CSS_VALUE_H__
'''
    doth += s_cpp_begin

    doth += 'enum NCSSVALUE {\n'
    ret = gen_enum('css_value.in', 'CSSVAL_')
    doth += ret[0]
    doth += ',\n'
    doth += '\tCSSVAL_LAST = %d\n' % (ret[1] - 1)
    doth += '};\n'
    doth += '''
void css_initVals(void);
void css_delVals(void);
const char** css_getValueNames();
'''
    doth += s_cpp_end
    doth += '#endif\n'

    f = open('css_value.h', 'w')
    f.write(doth)
    f.close()
    
    # 生成源文件
    dotc = s_comment
    dotc += '''
#include "../inc/config.h"
#include "../tools/strList.h"
#include "css_value.h"

static NStrList* l_cssValueNames = N_NULL;

void css_initVals(void)
{
    const char* vals = \\
'''

    f = open('css_value.in','r')
    lines = f.readlines()
    f.close()

    dotc += gen_string(lines, True, 4)
    dotc += '\t\t;\n'
    dotc += '''
    l_cssValueNames = strList_create(vals);
}

void css_delVals(void)
{
    strList_delete(&l_cssValueNames);
}

const char** css_getValueNames()
{
    return (const char**)l_cssValueNames->lst;
}
'''
    f = open('css_value.c', 'w')
    f.write(dotc)
    f.close()


# 生成颜色

def create_color():
    os.chdir('c:/nbk/stdc/css')

    f = open('color.in', 'r')
    lines = f.readlines()
    f.close()

    color = []
    for l in lines:
        l = string.strip(l)
        if len(l) == 0:
            continue
        m = string.split(l, ',')
        color.append(m[0])

    # 生成头文件
    doth = s_comment
    doth += '''
#ifndef __COLOR_H__
#define __COLOR_H__

#include "../inc/nbk_gdi.h"
'''
    doth += s_cpp_begin

    for l in color:
        doth += 'extern const NColor color%s;\n' % l

    doth += '\nenum COLORS {\n'
    ret = gen_enum('', 'CC_', color)
    doth += ret[0]
    doth += ',\n'
    doth += '\tCC_LASTCOLOR = %d\n' % (ret[1] - 1)
    doth += '};\n'
    doth += '\n#define MAX_COLOR_LEN\t%d\n' % ret[2]
    doth += '''
void css_initColor(void);
void css_delColor(void);
const char** css_getColorNames(void);
NColor* css_getColorValues(void);
'''
    doth += s_cpp_end
    doth += '#endif\n'

    f = open('color.h', 'w')
    f.write(doth)
    f.close()
    
    print 'color total %d\t max length %d' % (ret[1], ret[2])
    
    # 生成源文件
    dotc = s_comment
    dotc += '''
#include "../inc/config.h"
#include "../tools/strList.h"
#include "color.h"

'''

    for l in lines:
        l = string.strip(l)
        if len(l) == 0:
            continue
        m = string.split(l, ',')
        dotc += 'const NColor color%s = {%s, %s, %s, %s};\n' % (m[0], m[1], m[2], m[3], m[4])

    dotc += '''
static NStrList* l_colorNames = N_NULL;

static NColor l_colorValues[] = {
    {0, 0, 0, 0},
'''
    i = 0
    for l in lines:
        l = string.strip(l)
        if len(l) == 0:
            continue
        m = string.split(l, ',')
        if i > 0:
            dotc += ',\n'
        dotc += '\t{%s, %s, %s, %s}' % (m[1], m[2], m[3], m[4])
        i += 1
        
    dotc += '\n};\n'
    dotc += '''
void css_initColor(void)
{
    const char* colors = \\
'''
    cc = []
    for l in color:
        cc.append(string.lower(l))
    dotc += gen_string(cc, True, 5)
    dotc += '''     ;

    l_colorNames = strList_create(colors);
}
void css_delColor(void)
{
    strList_delete(&l_colorNames);
}

const char** css_getColorNames(void)
{
    return (const char**)l_colorNames->lst;
}

NColor* css_getColorValues(void)
{
    return l_colorValues;
}
'''

    f = open('color.c', 'w')
    f.write(dotc)
    f.close()
    
